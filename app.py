import time
from io import BytesIO
import pandas as pd
import streamlit as st
from scraper import (
    create_loader_anonymous,
    get_public_profile_data_anonymous,
    username_from_url,
)
from parsers import parse_followers_from_instagram_json

# --- Configuraci√≥n de p√°gina ---
st.set_page_config(
    page_title="Instagram Public Email Collector ‚Äî sin login",
    page_icon="üìß",
    layout="wide",
)

# CSS personalizado para mejorar la apariencia
st.markdown("""
<style>
    .main-header {
        text-align: center;
        padding: 2rem 0;
        background: linear-gradient(90deg, #833ab4, #fd1d1d, #fcb045);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        font-size: 2.5rem;
        font-weight: bold;
        margin-bottom: 1rem;
    }
    
    .subtitle {
        text-align: center;
        color: #666;
        font-size: 1.1rem;
        margin-bottom: 2rem;
        padding: 0 1rem;
    }
    
    .feature-box {
        background-color: #f8f9fa;
        padding: 1.5rem;
        border-radius: 10px;
        border-left: 4px solid #833ab4;
        margin: 1rem 0;
    }
    
    .stats-container {
        display: flex;
        justify-content: space-around;
        margin: 1rem 0;
    }
    
    .stat-item {
        text-align: center;
        padding: 1rem;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .warning-box {
        background-color: #fff3cd;
        border: 1px solid #ffeaa7;
        border-radius: 8px;
        padding: 1rem;
        margin: 1rem 0;
    }
    
    .success-box {
        background-color: #d4edda;
        border: 1px solid #c3e6cb;
        border-radius: 8px;
        padding: 1rem;
        margin: 1rem 0;
    }
</style>
""", unsafe_allow_html=True)

# Header mejorado
st.markdown('<div class="main-header">üìß Instagram Public Email Collector</div>', unsafe_allow_html=True)
st.markdown('<div class="subtitle">Extrae emails p√∫blicos de forma √©tica y responsable ‚Ä¢ Sin necesidad de login</div>', unsafe_allow_html=True)

# Aclaraci√≥n √∫til para usuarios con mejor dise√±o
with st.expander("üõ°Ô∏è **Informaci√≥n importante y l√≠mites de la herramienta**", expanded=False):
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("**‚úÖ Qu√© hace esta herramienta:**")
        st.markdown("""
        - üîç Extrae datos **p√∫blicos** de perfiles de Instagram
        - üìß Busca emails visibles en biograf√≠as y enlaces externos
        - üìä Procesa m√∫ltiples perfiles de forma autom√°tica
        - üíæ Exporta resultados en CSV y Excel
        """)
    
    with col2:
        st.markdown("**‚ö†Ô∏è Limitaciones importantes:**")
        st.markdown("""
        - üö´ No requiere login ni contrase√±as
        - üëÅÔ∏è Solo accede a informaci√≥n **p√∫blica**
        - üêå Incluye delays para evitar bloqueos
        - üìÅ Para seguidores: usa archivos oficiales de Instagram
        """)

# Loader en modo an√≥nimo (sin credenciales)
L = create_loader_anonymous()

# --- Tabs principales con iconos mejorados ---
tab1, tab2, tab3 = st.tabs([
    "üîé Perfil √∫nico", 
    "üìã Lista de usuarios", 
    "üë• Importar seguidores"
])

# =========================================================
# TAB 1: PERFIL √öNICO
# =========================================================
with tab1:
    st.markdown("### üéØ Analizar un perfil espec√≠fico")
    
    # Layout mejorado en columnas
    col1, col2 = st.columns([3, 1])
    
    with col1:
        url = st.text_input(
            "**URL de perfil o @username**",
            placeholder="Ejemplo: https://www.instagram.com/instagram/ o @instagram",
            help="Puedes usar la URL completa o solo el @username"
        )
    
    with col2:
        delay_single = st.number_input(
            "**Delay (segundos)**",
            min_value=0.0, max_value=5.0, step=0.5, value=1.0,
            key="delay_single",
            help="Tiempo de espera para evitar l√≠mites"
        )

    # Bot√≥n principal m√°s prominente
    if st.button("üöÄ **Extraer informaci√≥n del perfil**", type="primary", use_container_width=True):
        if not url.strip():
            st.error("‚ö†Ô∏è Por favor introduce una URL o @username v√°lido.")
        else:
            # Contenedor de progreso mejorado
            with st.container():
                progress_container = st.empty()
                status_container = st.empty()
                
                try:
                    status_container.info("üîÑ Procesando perfil...")
                    progress_bar = progress_container.progress(0)
                    
                    if delay_single > 0:
                        status_container.info(f"‚è≥ Esperando {delay_single}s para evitar l√≠mites...")
                        time.sleep(delay_single)
                    
                    progress_bar.progress(50)
                    status_container.info("üìä Extrayendo datos p√∫blicos...")
                    
                    data = get_public_profile_data_anonymous(L, url)
                    df = pd.DataFrame([data])
                    
                    progress_bar.progress(100)
                    status_container.success("‚úÖ ¬°Perfil procesado correctamente!")
                    
                    # Mostrar estad√≠sticas
                    if data.get('emails_count', 0) > 0:
                        st.success(f"üéâ ¬°Encontrados {data['emails_count']} email(s)!")
                    else:
                        st.warning("üì≠ No se encontraron emails p√∫blicos en este perfil")
                    
                    # Mostrar datos en formato mejorado
                    st.markdown("### üìã Resultados:")
                    st.dataframe(df, use_container_width=True)
                    
                    # Botones de descarga mejorados
                    col_csv, col_xlsx = st.columns(2)
                    with col_csv:
                        st.download_button(
                            "üìÑ Descargar CSV",
                            df.to_csv(index=False).encode("utf-8"),
                            file_name=f"{username_from_url(url)}_perfil.csv",
                            mime="text/csv",
                            use_container_width=True
                        )
                    
                    with col_xlsx:
                        buf = BytesIO()
                        df.to_excel(buf, index=False)
                        st.download_button(
                            "üìä Descargar Excel",
                            buf.getvalue(),
                            file_name=f"{username_from_url(url)}_perfil.xlsx",
                            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                            use_container_width=True
                        )
                        
                except Exception as e:
                    progress_container.empty()
                    status_container.error(f"‚ùå Error al procesar el perfil: {str(e)}")

# =========================================================
# TAB 2: LISTA DE USERNAMES
# =========================================================
with tab2:
    st.markdown("### üìä Procesamiento masivo de perfiles")
    
    # Entrada de datos mejorada
    input_method = st.radio(
        "**Selecciona el m√©todo de entrada:**",
        ["‚úèÔ∏è Escribir usernames", "üìÅ Subir archivo CSV"],
        horizontal=True
    )
    
    usernames = []
    
    if input_method == "‚úèÔ∏è Escribir usernames":
        col1, col2 = st.columns([2, 1])
        
        with col1:
            sample = "@instagram\n@natgeo\n@github\n@spotify"
            userlist_text = st.text_area(
                "**Lista de usernames** (uno por l√≠nea)",
                height=200,
                placeholder=sample,
                help="Escribe un @username por l√≠nea. El @ es opcional."
            )
            
            if userlist_text.strip():
                usernames = [u.strip().lstrip("@") for u in userlist_text.splitlines() if u.strip()]
        
        with col2:
            st.markdown("**üìù Consejos:**")
            st.markdown("""
            - Un username por l√≠nea
            - El s√≠mbolo @ es opcional
            - Se eliminan duplicados autom√°ticamente
            - Espacios en blanco se ignoran
            """)
    
    else:  # Upload CSV
        uploaded = st.file_uploader(
            "**Sube un archivo CSV con columna 'username'**", 
            type=["csv"],
            help="El archivo debe contener una columna llamada 'username'"
        )
        
        if uploaded is not None:
            try:
                df_in = pd.read_csv(uploaded)
                if "username" in df_in.columns:
                    usernames = df_in["username"].astype(str).str.strip().str.lstrip("@").tolist()
                    st.success(f"‚úÖ Archivo cargado: {len(usernames)} usernames encontrados")
                else:
                    st.error("‚ùå El CSV debe tener una columna llamada 'username'.")
            except Exception as e:
                st.error(f"‚ùå Error al leer el CSV: {e}")

    # Configuraci√≥n del procesamiento
    col1, col2, col3 = st.columns(3)
    
    with col1:
        delay_batch = st.number_input(
            "**Delay por perfil (seg)**",
            min_value=0.0, max_value=5.0, step=0.5, value=1.0,
            key="delay_batch",
            help="Tiempo entre peticiones para evitar bloqueos"
        )
    
    with col2:
        # Limpiar y mostrar stats
        usernames = sorted(set([u for u in usernames if u]))
        st.metric("üìä **Usernames √∫nicos**", len(usernames))
    
    with col3:
        if usernames:
            estimated_time = len(usernames) * delay_batch
            st.metric("‚è±Ô∏è **Tiempo estimado**", f"{estimated_time:.1f}s")

    # Bot√≥n de procesamiento
    if st.button("üöÄ **Procesar todos los perfiles**", type="primary", use_container_width=True, disabled=len(usernames)==0):
        if not usernames:
            st.error("‚ö†Ô∏è No hay usernames para procesar.")
        else:
            # Contenedor de progreso
            progress_container = st.container()
            
            with progress_container:
                st.info(f"üîÑ Iniciando procesamiento de {len(usernames)} perfiles...")
                
                # Barra de progreso y estad√≠sticas en tiempo real
                progress_bar = st.progress(0)
                status_text = st.empty()
                stats_container = st.empty()
                
                rows = []
                emails_found = 0
                errors_count = 0
                
                for i, u in enumerate(usernames, start=1):
                    try:
                        # Actualizar status
                        status_text.text(f"üìä Procesando: @{u} ({i}/{len(usernames)})")
                        
                        if delay_batch > 0:
                            time.sleep(delay_batch)
                        
                        data = get_public_profile_data_anonymous(L, u)
                        rows.append(data)
                        
                        # Contar emails encontrados
                        if data.get('emails_count', 0) > 0:
                            emails_found += data['emails_count']
                            
                    except Exception as e:
                        errors_count += 1
                        rows.append({
                            "username": u,
                            "error": str(e),
                            "emails": "",
                            "emails_count": 0,
                            "bio": "",
                            "external_url": "",
                            "full_name": "",
                            "is_private": None,
                            "email_sources": ""
                        })
                    
                    # Actualizar progreso y stats
                    progress_bar.progress(int(i * 100 / len(usernames)))
                    
                    # Mostrar estad√≠sticas en tiempo real
                    col1, col2, col3 = stats_container.columns(3)
                    col1.metric("‚úÖ Procesados", i)
                    col2.metric("üìß Emails encontrados", emails_found)
                    col3.metric("‚ùå Errores", errors_count)

                # Resultados finales
                df = pd.DataFrame(rows)
                
                # Mostrar resumen final
                st.success(f"üéâ ¬°Procesamiento completado!")
                
                # Estad√≠sticas finales
                col1, col2, col3, col4 = st.columns(4)
                col1.metric("üìä Total procesados", len(usernames))
                col2.metric("üìß Total emails", emails_found)
                col3.metric("‚úÖ Exitosos", len(usernames) - errors_count)
                col4.metric("‚ùå Errores", errors_count)
                
                # Mostrar tabla de resultados
                st.markdown("### üìã Resultados detallados:")
                st.dataframe(df, use_container_width=True)

                # Botones de descarga
                col_csv, col_xlsx = st.columns(2)
                with col_csv:
                    st.download_button(
                        "üìÑ Descargar CSV completo",
                        df.to_csv(index=False).encode("utf-8"),
                        file_name="emails_publicos_instagram_lote.csv",
                        mime="text/csv",
                        use_container_width=True
                    )
                
                with col_xlsx:
                    buf = BytesIO()
                    df.to_excel(buf, index=False)
                    st.download_button(
                        "üìä Descargar Excel completo",
                        buf.getvalue(),
                        file_name="emails_publicos_instagram_lote.xlsx",
                        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                        use_container_width=True
                    )

# =========================================================
# TAB 3: IMPORTAR SEGUIDORES (JSON/ZIP OFICIAL)
# =========================================================
with tab3:
    st.markdown("### üë• Procesar seguidores desde archivo oficial")
    
    # Instrucciones mejoradas
    with st.container():
        st.markdown("""
        <div class="feature-box">
        <h4>üì± ¬øC√≥mo obtener el archivo de seguidores?</h4>
        <ol>
        <li><strong>Instagram App</strong> ‚Üí Configuraci√≥n ‚Üí Privacidad ‚Üí Descargar tu informaci√≥n</li>
        <li>Solicita el archivo en formato <strong>JSON</strong></li>
        <li>Instagram te enviar√° un ZIP con tus datos</li>
        <li>Sube aqu√≠ el <strong>ZIP completo</strong> o extrae el archivo <code>followers_*.json</code></li>
        </ol>
        </div>
        """, unsafe_allow_html=True)
    
    # Upload mejorado
    col1, col2 = st.columns([2, 1])
    
    with col1:
        up = st.file_uploader(
            "**üìÅ Sube tu archivo de seguidores**", 
            type=["json", "zip"],
            help="Acepta archivos JSON individuales o el ZIP completo de Instagram"
        )
    
    with col2:
        st.markdown("**üìã Formatos aceptados:**")
        st.markdown("""
        - üì¶ **ZIP oficial** de Instagram
        - üìÑ **JSON** de seguidores extra√≠do
        - üîç Auto-detecta archivos relevantes
        """)
    
    # Configuraci√≥n del procesamiento
    col1, col2 = st.columns(2)
    
    with col1:
        limit = st.number_input(
            "**üéØ L√≠mite de perfiles a procesar**", 
            min_value=1, max_value=10000, value=200, step=50,
            help="Para evitar tiempos excesivos, limita la cantidad inicial"
        )
    
    with col2:
        delay_follow = st.number_input(
            "**‚è±Ô∏è Delay por perfil (seg)**",
            min_value=0.0, max_value=5.0, step=0.5, value=1.0,
            key="delay_follow",
            help="Tiempo entre peticiones para evitar bloqueos"
        )

    # Bot√≥n de procesamiento
    if st.button("üöÄ **Procesar archivo de seguidores**", type="primary", use_container_width=True, disabled=up is None):
        if not up:
            st.error("‚ö†Ô∏è Por favor sube un archivo JSON o ZIP.")
        else:
            try:
                # An√°lisis inicial del archivo
                with st.spinner("üîç Analizando archivo..."):
                    usernames = []
                    
                    if up.type == "application/zip" or up.name.lower().endswith(".zip"):
                        import pyzipper
                        with pyzipper.AESZipFile(up, "r") as zf:
                            candidates = [
                                n for n in zf.namelist()
                                if "followers" in n.lower() and n.lower().endswith(".json")
                            ]
                            
                            if not candidates:
                                st.error("‚ùå No se encontraron archivos JSON de seguidores en el ZIP.")
                                st.stop()
                            
                            st.info(f"üìÅ Archivos encontrados: {', '.join(candidates)}")
                            
                            for name in candidates:
                                data_bytes = zf.read(name)
                                usernames.extend(parse_followers_from_instagram_json(data_bytes))
                    else:
                        usernames = parse_followers_from_instagram_json(up.getvalue())

                # Procesamiento de usernames
                usernames = sorted(set(usernames))
                
                if not usernames:
                    st.warning("‚ö†Ô∏è No se detectaron usernames de seguidores en el archivo.")
                    st.stop()

                # Aplicar l√≠mite
                original_count = len(usernames)
                usernames = usernames[:limit]
                
                # Mostrar estad√≠sticas iniciales
                col1, col2, col3 = st.columns(3)
                col1.metric("üë• Total en archivo", original_count)
                col2.metric("üéØ A procesar", len(usernames))
                col3.metric("‚è±Ô∏è Tiempo estimado", f"{len(usernames) * delay_follow:.1f}s")
                
                if original_count > limit:
                    st.info(f"‚ÑπÔ∏è Se procesar√°n los primeros {limit} seguidores de {original_count} totales.")

                # Procesamiento con progreso mejorado
                st.markdown("### üîÑ Procesando seguidores...")
                
                progress_bar = st.progress(0)
                status_text = st.empty()
                stats_container = st.empty()
                
                rows = []
                emails_found = 0
                errors_count = 0
                
                for i, u in enumerate(usernames, start=1):
                    try:
                        # Actualizar status
                        status_text.text(f"üìä Procesando seguidor: @{u} ({i}/{len(usernames)})")
                        
                        if delay_follow > 0:
                            time.sleep(delay_follow)
                        
                        data = get_public_profile_data_anonymous(L, u)
                        rows.append(data)
                        
                        # Contar emails
                        if data.get('emails_count', 0) > 0:
                            emails_found += data['emails_count']
                            
                    except Exception as e:
                        errors_count += 1
                        rows.append({
                            "username": u,
                            "error": str(e),
                            "emails": "",
                            "emails_count": 0,
                            "bio": "",
                            "external_url": "",
                            "full_name": "",
                            "is_private": None,
                            "email_sources": ""
                        })
                    
                    # Actualizar progreso
                    progress_bar.progress(int(i * 100 / len(usernames)))
                    
                    # Stats en tiempo real cada 10 procesamientos
                    if i % 10 == 0 or i == len(usernames):
                        col1, col2, col3 = stats_container.columns(3)
                        col1.metric("‚úÖ Procesados", i)
                        col2.metric("üìß Emails encontrados", emails_found)
                        col3.metric("‚ùå Errores", errors_count)

                # Resultados finales
                df = pd.DataFrame(rows)
                
                st.success("üéâ ¬°Procesamiento de seguidores completado!")
                
                # Estad√≠sticas finales
                col1, col2, col3, col4 = st.columns(4)
                col1.metric("üë• Seguidores procesados", len(usernames))
                col2.metric("üìß Total emails encontrados", emails_found)
                col3.metric("‚úÖ Perfiles exitosos", len(usernames) - errors_count)
                col4.metric("üìä Tasa de √©xito", f"{((len(usernames) - errors_count) / len(usernames) * 100):.1f}%")
                
                # Tabla de resultados
                st.markdown("### üìã Resultados de seguidores:")
                st.dataframe(df, use_container_width=True)

                # Botones de descarga
                col_csv, col_xlsx = st.columns(2)
                with col_csv:
                    st.download_button(
                        "üìÑ Descargar CSV de seguidores",
                        df.to_csv(index=False).encode("utf-8"),
                        file_name="seguidores_emails_publicos.csv",
                        mime="text/csv",
                        use_container_width=True
                    )
                
                with col_xlsx:
                    buf = BytesIO()
                    df.to_excel(buf, index=False)
                    st.download_button(
                        "üìä Descargar Excel de seguidores",
                        buf.getvalue(),
                        file_name="seguidores_emails_publicos.xlsx",
                        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                        use_container_width=True
                    )
                    
            except Exception as e:
                st.error(f"‚ùå Error procesando el archivo: {str(e)}")

# Footer mejorado
st.markdown("---")
st.markdown("""
<div style="text-align: center; color: #666; padding: 2rem;">
    <p>üõ°Ô∏è <strong>Uso responsable:</strong> Esta herramienta solo accede a informaci√≥n p√∫blica de Instagram.</p>
    <p>üìß Utiliza los emails obtenidos de forma √©tica y respetando las pol√≠ticas anti-spam.</p>
    <p>‚öñÔ∏è El usuario es responsable del cumplimiento de las leyes locales de privacidad y protecci√≥n de datos.</p>
</div>
""", unsafe_allow_html=True)